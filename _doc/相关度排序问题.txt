问题描述：将请求与数据库各类对象进行相关度计算，在匹配数、总标签数、用户相关度、热度、新鲜度等方面进行综合考虑，对各类对象进行排序（按相关度降序排序）
输入：请求的用户信息、关键字列表（实际也是一个标签列表）
输出：已按相关降序排序的各类对象

注：
新鲜度就是条目时间戳和现在时间戳的差
热度由平时访问的时候形成固定值存储在条目里
本人相关度由条目创建者和本人是否同人、是否关联人、是否同组、是否关联组决定

correlationSort(userId,keywords):sortedObjects{
	tags<-searchTags(keywords)
	for each column{
		for each tag in tags{
			objects<-column.getObjectsByTag(tag)
			union(oneColumnObjects,objects)
		}
		for each object in oneColumnObjects{
			object.correlationDegree<-computeCorrelationDegree(userId,keywords,object,column)
		}
		sortBycorrelationDegree(oneColumnObjects)
		merge(allObjects,oneColumnObjects)
	}
	return allObjects
}

computeCorrelationDegree(userId,keywords,object,column):correlationDegree{
	tagWeight<-0.6
	freshWeight<-0.1
	hotWeight<-0.1
	peopleWeight<-0.2
	commomCount<-countOfCommonElements(keywords,object.tags)
	totalCount<-object.tags.length
	tagDegree<-commonCount/totalCount
	freshDegree<-(timeNow-object.publishTime)/(timeNow-column.createTime)
	hotDegree<-object.clickCount/column.clickCount
	peopleDegree<-computePeopleDegree(userId,object)
	return tagDegree*tagWeight+freshDegree*freshWeight+hotDegree*hotWeight+peopleDegree*peopleWeight
}

computePeopleDegree(userId,object):peopleDegree{
	if(isSelf(userId,object.creator)){
		peopleDegree<-4
	}
	else if(isRelatedPeople(userId,object.creator)){
		peopleDegree<-3
	}
	else if(isSameGroup(userId,object.creator)){
		peopleDegree<-2
	}
	else if(isRelatedGroup(userId,object.creator)){
		peopleDegree<-1
	}
	else{
		peopleDegree<-0
	}
	return peopleDegree/(1+2+3+4)
}

merge(left,right):merged{
	leftIndex<-1
	rightIndex<-1
	for(mergedIndex<-1;leftIndex<=left.length&&rightIndex<=right.length;mergedIndex++){
		if(left[leftIndex].correlationDegree<=right[rightIndex].correlationDegree){
			merged[mergedIndex]<-left[leftIndex]
			leftIndex++
		}
		else{
			merged[mergedIndex]<-right[rightIndex]
			rightIndex++
		}
	}
	for(;leftIndex<=left.length;mergedIndex++){
		merged[mergedIndex]<-left[leftIndex]
	}
	for(;rightIndex<=right.length;mergedIndex++){
		merged[mergedIndex]<-right[rightIndex]
	}
	return merged
}

heapAdjust(heap,rootIndex,lastNodeIndex){
	rootNode<-heap[rootIndex]
	for(i<-2*rootIndex,continue<-true;i<=lastNodeIndex&&continue;i*<-2){
		if(i<lastNodeIndex&&heap[i].correlationDegree>heap[i+1].correlationDegree){
			i++
		}
		if(rootNode.correlationDegree<heap[i].correlationDegree){
			continue<-false
		}
		else{
			heap[rootIndex]<-heap[i]
			rootIndex<-i
		}
	}
	heap[rootIndex]<-rootNode
}

heapSort(heap){
	for(i<-heap.length/2;i>=1;i--){
		heapAdjust(heap,i,heap.length)
	}
	for(i<-heap.length;i>1;i--){
		exchange(heap[1],heap[i])
		heapAdjust(heap,1,i-1)
	}
}

sortBycorrelationDegree(correlationDegrees){
	heapSort(correlationDegrees)
}
